#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>
#include <fstream>
#include <sstream>
#include <string>
#include <cstdio>

#include <boost/filesystem.hpp>
#include <boost/thread.hpp>

#include "royale.hpp"
#include "royale/IPlaybackStopListener.hpp"
#include "royale/IReplay.hpp"
#include "sample_utils/PlatformResources.hpp"

#include <pcl/common/common.h>
#include <pcl/point_types.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/registration/icp.h>

#define MAX_Z_DISTANCE 5.0

//globals to communicate and protect between threads
std::mutex picoMut;

pcl::PointCloud<pcl::PointXYZ>::Ptr DepthDataToPCL(royale::DepthData* data)
{
	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>());
	cloud->height = data->height;
	cloud->width = data->width;
	//cloud.header.stamp = data->timeStamp;
	
	for (auto point : data->points)
	{
		if(point.z < MAX_Z_DISTANCE && point.z != 0)
		{
			pcl::PointXYZ p;
			p.x = point.x;
			p.y = point.y;
			p.z = point.z;
			cloud->push_back(p);
		}
	}
	return cloud;
}
pcl::PointCloud<pcl::PointXYZI>::Ptr DepthDataToPCLI(royale::DepthData* data)
{
	pcl::PointCloud<pcl::PointXYZI>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZI>());
	cloud->height = data->height;
	cloud->width = data->width;
	//cloud.header.stamp = data->timeStamp;
	
	for (auto point : data->points)
	{
		if(point.z < MAX_Z_DISTANCE && point.z != 0)
		{
			pcl::PointXYZI p;
			p.x = point.x;
			p.y = point.y;
			p.z = point.z;
			p.intensity = point.grayValue;
			cloud->push_back(p);
		}
	}
	return cloud;
}

class cameraListener : public royale::IDepthDataListener
{
public:
	bool hasData;
	royale::DepthData data;
	pcl::visualization::PCLVisualizer::Ptr viewer;
	pcl::PointCloud<pcl::PointXYZI>::Ptr cloud;

	cameraListener() : hasData(false)
	{
		viewer = pcl::visualization::PCLVisualizer::Ptr(new pcl::visualization::PCLVisualizer("data viewer"));
		viewer->addCoordinateSystem(0.1);
		viewer->initCameraParameters();
	}

	void writePLY(const std::string &filename, royale::DepthData *data)
	{
		// For an explanation of the PLY file format please have a look at
		// https://en.wikipedia.org/wiki/PLY_(file_format)

		std::ofstream outputFile;
		std::stringstream stringStream;

		outputFile.open(filename, std::ofstream::out);

		if (outputFile.fail())
		{
			std::cerr << "Outputfile " << filename << " could not be opened!" << std::endl;
			return;
		}
		else
		{
			// if the file was opened successfully write the PLY header
			stringStream << "ply" << std::endl;
			stringStream << "format ascii 1.0" << std::endl;
			stringStream << "comment Generated by pico_recorder" << std::endl;
			stringStream << "element vertex " << data->points.size() << std::endl;
			stringStream << "property float x" << std::endl;
			stringStream << "property float y" << std::endl;
			stringStream << "property float z" << std::endl;
			stringStream << "element face 0" << std::endl;
			stringStream << "property list uchar int vertex_index" << std::endl;
			stringStream << "end_header" << std::endl;

			// output XYZ coordinates into one line
			for (size_t i = 0; i < data->points.size(); ++i)
			{
				stringStream << data->points.at(i).x << " " << data->points.at(i).y << " " << data->points.at(i).z << std::endl;
			}
			// output stringstream to file and close it
			outputFile << stringStream.str();
			outputFile.close();
		}
	}
		void writePLY(const std::string &filename, pcl::PointCloud<pcl::PointXYZ>::Ptr data)
	{
		// For an explanation of the PLY file format please have a look at
		// https://en.wikipedia.org/wiki/PLY_(file_format)

		std::ofstream outputFile;
		std::stringstream stringStream;

		outputFile.open(filename, std::ofstream::out);

		if (outputFile.fail())
		{
			std::cerr << "Outputfile " << filename << " could not be opened!" << std::endl;
			return;
		}
		else
		{
			// if the file was opened successfully write the PLY header
			stringStream << "ply" << std::endl;
			stringStream << "format ascii 1.0" << std::endl;
			stringStream << "comment Generated by pico_recorder" << std::endl;
			stringStream << "element vertex " << data->points.size() << std::endl;
			stringStream << "property float x" << std::endl;
			stringStream << "property float y" << std::endl;
			stringStream << "property float z" << std::endl;
			stringStream << "element face 0" << std::endl;
			stringStream << "property list uchar int vertex_index" << std::endl;
			stringStream << "end_header" << std::endl;
			// output XYZ coordinates into one line
			for (size_t i = 0; i < data->points.size(); ++i)
			{
				stringStream << data->points.at(i).x << " " << data->points.at(i).y << " " << data->points.at(i).z << std::endl;
			}
			// output stringstream to file and close it
			outputFile << stringStream.str();
			outputFile.close();
		}
	}

	void onNewData(const royale::DepthData *data) override
	{
		//std::cout << "onnewdata\n";
		picoMut.lock();
		this->data = *data;
		hasData = true;
		picoMut.unlock();
		
		cloud = DepthDataToPCLI(&this->data);
		if (!viewer->updatePointCloud<pcl::PointXYZI>(cloud, "sample cloud"))
					viewer->addPointCloud<pcl::PointXYZI>(cloud, "sample cloud");
		viewer->spinOnce();
		//std::cout << "onnewdata done\n";
	}
};

int setupCamera(std::shared_ptr<royale::ICameraDevice> &cameraDevice, int selectedUseCase)
{
	royale::CameraManager manager;

	auto camlist = manager.getConnectedCameraList();
	//std::cout << "Detected " << camlist.size() << " camera(s)." << std::endl;
	if (!camlist.empty())
	{
		std::cout << "CamID for first device: " << camlist.at(0).c_str() << " with a length of (" << camlist.at(0).length() << ")" << std::endl;
		cameraDevice = manager.createCamera(camlist[0]);
	}
	//std::cout << "created camera\n";

	if (cameraDevice == nullptr)
	{
		std::cerr << "Cannot create the camera device" << std::endl;
		return 1;
	}
	//std::cout << "before initialize\n";

	// IMPORTANT: call the initialize method before working with the camera device
	if (cameraDevice->initialize() != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Cannot initialize the camera device" << std::endl;
		return 1;
	}
	//std::cout << "after cam initialize\n";


	/* available usecases from the pico flex
	0	MODE_9_5FPS_2000
	1	MODE_9_10FPS_1000
	2	MODE_9_15FPS_700
	3	MODE_9_25FPS_450
	4	MODE_5_35FPS_600
	5	MODE_5_45FPS_500
	6	MODE_MIXED_30_5
	7	MODE_MIXED_50_5
	8	Low_Noise_Extended
	9	Fast_Acquisition
		*/
	royale::Vector<royale::String> useCases;
	auto status = cameraDevice->getUseCases(useCases);
	//std::cout << "got use cases\n";
	//for (auto stat : useCases)
	//	std::cout << stat << "\n";
	//std::cout << "\n";

	if (status != royale::CameraStatus::SUCCESS || useCases.empty())
	{
		std::cerr << "No use cases are available" << std::endl;
		std::cerr << "getUseCases() returned: " << getErrorString(status) << std::endl;
		return 1;
	}

	// choose a use case
	auto selectedUseCaseIdx = selectedUseCase;
	std::cout << "Choosing useCase " << useCases[selectedUseCaseIdx] << "\n";

	// set an operation mode
	if (cameraDevice->setUseCase(useCases.at(selectedUseCaseIdx)) != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Error setting use case" << std::endl;
		return 1;
	}
	//std::cout << "before setexposuremode\n";

	if (cameraDevice->setExposureMode(royale::ExposureMode::MANUAL) != royale::CameraStatus::SUCCESS)
	{
		std::cout << "failed to set fixed exposure mode\n";
		return 1;
	}
	uint16_t maxFrameRate;
	cameraDevice->getFrameRate(maxFrameRate);
	std::cout << "Framerate: " << maxFrameRate << "\n";
	return 0;
}

int main(int argc, char *argv[])
{
	//std::cout << "after starting arduino thread\n";
	//boost::this_thread::sleep(boost::posix_time::microseconds(10000000));
	std::unique_ptr<cameraListener> listener;
	std::shared_ptr<royale::ICameraDevice> cameraDevice;
	auto result = setupCamera(cameraDevice, 5);
	if(result != 0)
	{
		std::cout << "failed to setup camera" << "\n";
		return result;
	}
	// Create and register the data listener
	//std::cout << "before listener.reset\n";
	listener.reset(new cameraListener());
	if (cameraDevice->registerDataListener(listener.get()) != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Error registering data listener" << std::endl;
		return 1;
	}
	std::vector<int> exposures = {50, 100, 500};
	std::cout << "Starting to capture... \n";
	std::string framerate = "fps45_";
	for (auto exposure : exposures)
	{
		if (cameraDevice->setExposureTime(exposure) != royale::CameraStatus::SUCCESS)
		{
			std::cout << "failed to set exposure: " << exposure << "\n";
			continue;
		}
		else
		{
			std::cout << "recording with exposure: " << exposure << "\n";
			std::string folderName = framerate + "exp_" + std::to_string(exposure);

			boost::filesystem::path dir(folderName);
			if (!boost::filesystem::create_directory(dir))
			{
				std::cout << "failed to create directory: " << folderName << " -does it already exist? \n";
				continue;
			}
			// start capture mode
			if (cameraDevice->startCapture() != royale::CameraStatus::SUCCESS)
			{
				std::cerr << "Error starting the capturing" << std::endl;
				continue;
			}	

			int n_frames = 1;
			while (n_frames < 51)
			{
				picoMut.lock();
				if(listener->hasData)
				{
					listener->hasData = false;
					//got the data, now save it as n.ply and n.txt
					std::string plyName, txtName;
					plyName = folderName + "/" + std::to_string(n_frames) + ".ply";
					listener->writePLY(plyName, (&listener->data));

					picoMut.unlock();

					n_frames ++;
				}
				else
				{
					picoMut.unlock();
					boost::this_thread::sleep(boost::posix_time::microseconds(1000));
					continue;
				}
			}
			if (cameraDevice->stopCapture() != royale::CameraStatus::SUCCESS)
			{
				std::cerr << "Error stopping the capturing" << std::endl;
			}
		}
	}

	if (cameraDevice->stopCapture() != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Error stopping the capturing" << std::endl;
		return 1;
	}

	royale::Vector<royale::String> useCases;
	auto status = cameraDevice->getUseCases(useCases);
	//std::cout << "got use cases\n";
	//for (auto stat : useCases)
	//	std::cout << stat << "\n";
	//std::cout << "\n";

	if (status != royale::CameraStatus::SUCCESS || useCases.empty())
	{
		std::cerr << "No use cases are available" << std::endl;
		std::cerr << "getUseCases() returned: " << getErrorString(status) << std::endl;
		return 1;
	}
	int selectedUseCaseId = 1;
	if (cameraDevice->setUseCase(useCases.at(selectedUseCaseId)) != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Error setting use case" << std::endl;
		return 1;
	}
	else
	{
		std::cout << "selected next usecase " << useCases.at(selectedUseCaseId) << "\n";
	}
	framerate = "fps10_";
	exposures = {1000};
	for (auto exposure : exposures)
	{
		if (cameraDevice->setExposureTime(exposure) != royale::CameraStatus::SUCCESS)
		{
			std::cout << "failed to set exposure: " << exposure << "\n";
			continue;
		}
		else
		{
			std::cout << "recording with exposure: " << exposure << "\n";
			std::string folderName = framerate + "exp_" + std::to_string(exposure);

			boost::filesystem::path dir(folderName);
			if (!boost::filesystem::create_directory(dir))
			{
				std::cout << "failed to create directory: " << folderName << " -does it already exist? \n";
				continue;
			}
			// start capture mode
			if (cameraDevice->startCapture() != royale::CameraStatus::SUCCESS)
			{
				std::cerr << "Error starting the capturing" << std::endl;
				continue;
			}	

			int n_frames = 1;
			while (n_frames < 51)
			{
				picoMut.lock();
				if(listener->hasData)
				{
					listener->hasData = false;
					//got the data, now save it as n.ply and n.txt
					std::string plyName, txtName;
					plyName = folderName + "/" + std::to_string(n_frames) + ".ply";
					listener->writePLY(plyName, (&listener->data));

					picoMut.unlock();

					n_frames ++;
				}
				else
				{
					picoMut.unlock();
					boost::this_thread::sleep(boost::posix_time::microseconds(1000));
					continue;
				}
			}
			if (cameraDevice->stopCapture() != royale::CameraStatus::SUCCESS)
			{
				std::cerr << "Error stopping the capturing" << std::endl;
			}
		}
	}

	std::cout << "\n done with all recordings.\n";
	//stop capture mode
	if (cameraDevice->stopCapture() != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Error stopping the capturing" << std::endl;
		return 1;
	}
	return(0);
}