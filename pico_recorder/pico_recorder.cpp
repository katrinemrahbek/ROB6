/****************************************************************************\
 * Copyright (C) 2017 Infineon Technologies & pmdtechnologies ag
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 * KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 * PARTICULAR PURPOSE.
 *
 \****************************************************************************/

#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>
#include <fstream>
#include <sstream>
#include <string>
#include <cstdio>

#include <boost/filesystem.hpp>
#include <boost/thread.hpp>

#include "royale.hpp"
#include "royale/IPlaybackStopListener.hpp"
#include "royale/IReplay.hpp"
#include "sample_utils/PlatformResources.hpp"


using namespace std;

namespace
{
	/**
	 * This sample is a command line application that takes an rrf filename as input and outputs a
	 * PLY file for each frame of the recording (into the current working directory).
	 *
	 * Royale's API for playing an .rrf file is the same as for capturing data from a camera, you
	 * use CameraManager to create an ICameraDevice for the .rrf file, and then receive the data as
	 * IDepthDataListener::onNewData callbacks.
	 *
	 * With a recording, the onNewData callback isn't time-critical, so doesn't require the
	 * thread-handling of sampleRetrieveData. A recording also has a beginning, an end, and the
	 * possibility to fast-forward and rewind, which are supported through the IReplay interface.
	 */
	class MyListener : public royale::IDepthDataListener
	{
	public:



		MyListener() :
			m_frameNumber(50), maxNumFrames(50), done(false)
		{
		}
		uint32_t m_frameNumber; // The current frame number
		uint32_t maxNumFrames;
		string filePrefix;
		bool done;

		void writePLY(const string &filename, const royale::DepthData *data)
		{
			// For an explanation of the PLY file format please have a look at
			// https://en.wikipedia.org/wiki/PLY_(file_format)

			ofstream outputFile;
			stringstream stringStream;

			outputFile.open(filename, ofstream::out);

			if (outputFile.fail())
			{
				cerr << "Outputfile " << filename << " could not be opened!" << endl;
				return;
			}
			else
			{
				// if the file was opened successfully write the PLY header
				stringStream << "ply" << endl;
				stringStream << "format ascii 1.0" << endl;
				stringStream << "comment Generated by sampleExportPLY" << endl;
				stringStream << "element vertex " << data->points.size() << endl;
				stringStream << "property float x" << endl;
				stringStream << "property float y" << endl;
				stringStream << "property float z" << endl;
				stringStream << "element face 0" << endl;
				stringStream << "property list uchar int vertex_index" << endl;
				stringStream << "end_header" << endl;

				// output XYZ coordinates into one line
				for (size_t i = 0; i < data->points.size(); ++i)
				{
					stringStream << data->points.at(i).x << " " << data->points.at(i).y << " " << data->points.at(i).z << endl;
				}

				// output stringstream to file and close it
				outputFile << stringStream.str();
				outputFile.close();
			}
		}

		void onNewData(const royale::DepthData *data) override
		{
			if (m_frameNumber < maxNumFrames)
			{
				stringstream filename;

				m_frameNumber++;

				cout << "Exporting frame " << m_frameNumber << endl;
				filename << filePrefix << "/" << m_frameNumber << ".ply";

				writePLY(filename.str(), data);
			}
			else
			{
				done = true;
			}
		}

	private:
	};

	class MyPlaybackStopListener : public royale::IPlaybackStopListener
	{
	public:
		MyPlaybackStopListener()
		{
			m_playbackRunning = true;
		}

		void onPlaybackStopped() override
		{
			lock_guard<mutex> lock(m_stopMutex);
			m_playbackRunning = false;
		}

		void waitForStop()
		{
			bool running = true;
			do
			{
				{
					lock_guard<mutex> lock(m_stopMutex);
					running = m_playbackRunning;
				}

				this_thread::sleep_for(chrono::milliseconds(50));
			} while (running);
		}

	private:
		mutex m_stopMutex;      // Mutex to synchronize the access to m_playbackRunning
		bool m_playbackRunning; // Shows if the playback is still running
	};
}

void fakeReturn(int returnValue)
{
	std::cout << "press enter to exit";
	std::getchar();
	exit(returnValue);
}

int main(int argc, char *argv[])
{
	// This is the data listener which will receive callbacks.  It's declared
	// before the cameraDevice so that, if this function exits with a 'return'
	// statement while the camera is still capturing, it will still be in scope
	// until the cameraDevice's destructor implicitly deregisters the listener.
	unique_ptr<MyListener> listener;

	// PlaybackStopListener which will be called as soon as the playback stops.
	MyPlaybackStopListener stopListener;

	// Royale's API treats the .rrf file as a camera, which it captures data from.
	unique_ptr<royale::ICameraDevice> cameraDevice;
	royale::CameraManager manager;
	/*
	// check the command line for a given file
	if (argc < 2)
	{
		cout << "Usage " << argv[0] << " rrfFileToExport" << endl;
		cout << endl;
		cout << "Each frame of the recording is saved as a separate .ply file " << endl;
		cout << "in the current directory." << endl;
		return 1;
	}

	// Use the camera manager to open the recorded file, this block scope is because we can allow
	// the CameraManager to go out of scope once the file has been opened.
	*/
	/*
	{
		royale::CameraManager manager;

		auto camlist = manager.getConnectedCameraList();
		cout << "Detected " << camlist.size() << " camera(s)." << endl;
		if (!camlist.empty())
		{
			cout << "CamID for first device: " << camlist.at(0).c_str() << " with a length of (" << camlist.at(0).length() << ")" << endl;
			cameraDevice = manager.createCamera(camlist[0]);
		}
	}

	// if the file was loaded correctly the cameraDevice is now available
	if (cameraDevice == nullptr)
	{
		cerr << "Cannot open camera " << endl;
		return 1;
	}

	/*
	// cast the cameraDevice to IReplay which offers more options for playing
	// back recordings
	auto replayControls = dynamic_cast<royale::IReplay *> (cameraDevice.get());

	if (replayControls == nullptr)
	{
		cerr << "Unable to cast to IReplay interface" << endl;
		return 1;
	}
	*/

	// IMPORTANT: call the initialize method before working with the camera device
	/*if (cameraDevice->initialize() != royale::CameraStatus::SUCCESS)
	{
		cerr << "Cannot initialize the camera device" << endl;
		return 1;
	}*/

	/*
	// turn off the looping of the playback
	replayControls->loop(false);

	// Turn off the timestamps to speed up the conversion. If timestamps are enabled, an .rrf that
	// was recorded at 5FPS will generate callbacks to onNewData() at only 5 callbacks per second.
	replayControls->useTimestamps(false);

	// retrieve the total number of frames from the recording
	auto numFrames = replayControls->frameCount();
	*/

	/*
	// register a playback stop listener. This will be called as soon
	// as the file has been played back once (because loop is turned off)
	replayControls->registerStopListener(&stopListener);
	*/
	/*
	royale::Vector<royale::String> useCases;
	auto status = cameraDevice->getUseCases(useCases);
	//for (auto stat : useCases)
	//	std::cout << stat << "\n";
	//std::cout << "\n";

	if (status != royale::CameraStatus::SUCCESS || useCases.empty())
	{
		cerr << "No use cases are available" << endl;
		cerr << "getUseCases() returned: " << getErrorString(status) << endl;
		return 1;
	}*/

	/*
	0	MODE_9_5FPS_2000
	1	MODE_9_10FPS_1000
	2	MODE_9_15FPS_700
	3	MODE_9_25FPS_450
	4	MODE_5_35FPS_600
	5	MODE_5_45FPS_500
	6	MODE_MIXED_30_5
	7	MODE_MIXED_50_5
	8	Low_Noise_Extended
	9	Fast_Acquisition
		*/
	//std::vector<int> chosenUseCases = { 0,1,2,3,4,5,8,9};
	/*int useCase = 0u;
	std::cout << "Found " << useCases.size() << " useCases \n";
	if (cameraDevice->setUseCase(useCases.at(useCase)) != royale::CameraStatus::SUCCESS);
	{
		std::cout << "failed to set usecase " << useCases[useCase] << "\n";
		return 1;
	}*/
	auto camlist = manager.getConnectedCameraList();
	cout << "Detected " << camlist.size() << " camera(s)." << endl;
	if (!camlist.empty())
	{
		cout << "CamID for first device: " << camlist.at(0).c_str() << " with a length of (" << camlist.at(0).length() << ")" << endl;
		cameraDevice = manager.createCamera(camlist[0]);
	}

	// the camera device is now available and CameraManager can be deallocated here

	if (cameraDevice == nullptr)
	{
		cerr << "Cannot create the camera device" << endl;
		return 1;
	}

	// IMPORTANT: call the initialize method before working with the camera device
	if (cameraDevice->initialize() != royale::CameraStatus::SUCCESS)
	{
		cerr << "Cannot initialize the camera device" << endl;
		return 1;
	}

	royale::Vector<royale::String> useCases;
	auto status = cameraDevice->getUseCases(useCases);
	for (auto stat : useCases)
		std::cout << stat << "\n";
	std::cout << "\n";

	if (status != royale::CameraStatus::SUCCESS || useCases.empty())
	{
		cerr << "No use cases are available" << endl;
		cerr << "getUseCases() returned: " << getErrorString(status) << endl;
		return 1;
	}

	// choose a use case
	auto selectedUseCaseIdx = 5u;
	std::cout << "Choosing useCase " << selectedUseCaseIdx << "\n";

	// set an operation mode
	if (cameraDevice->setUseCase(useCases.at(selectedUseCaseIdx)) != royale::CameraStatus::SUCCESS)
	{
		cerr << "Error setting use case" << endl;
		return 1;
	}

	std::vector<int> exposures = {50, 100, 200, 300, 400, 500 };
	if (cameraDevice->setExposureMode(royale::ExposureMode::MANUAL) != royale::CameraStatus::SUCCESS)
	{
		std::cout << "failed to set fixed exposure mode\n";
		return 1;
	}
	uint16_t maxFrameRate;
	cameraDevice->getFrameRate(maxFrameRate);
	std::cout << "framerate: " << maxFrameRate << "\n";


	// Create and register the data listener
	listener.reset(new MyListener());
	if (cameraDevice->registerDataListener(listener.get()) != royale::CameraStatus::SUCCESS)
	{
		cerr << "Error registering data listener" << endl;
		return 1;
	}

	for (auto exposure : exposures)
	{
		if (cameraDevice->setExposureTime(exposure) != royale::CameraStatus::SUCCESS)
		{
			std::cout << "failed to set exposure: " << exposure << "\n";
			continue;
		}
		else
		{
			std::cout << "recording with exposure: " << exposure << "\n";
			std::string folderName = "exp_" + std::to_string(exposure);
			listener->filePrefix = folderName;
			listener->m_frameNumber = 0;
			listener->done = false;
			boost::filesystem::path dir(folderName);
			if (!boost::filesystem::create_directory(dir))
			{
				std::cout << "failed to create directory: " << folderName << "\n does it already exist? \n";
				continue;
			}
			// start capture mode
			if (cameraDevice->startCapture() != royale::CameraStatus::SUCCESS)
			{
				cerr << "Error starting the capturing" << endl;
				continue;
			}
			while (!listener->done)
			{
				boost::this_thread::sleep(boost::posix_time::microseconds(100000));
			}
			if (cameraDevice->stopCapture() != royale::CameraStatus::SUCCESS)
			{
				cerr << "Error stopping the capturing" << endl;
			}
		}
	}
	cout << "\n done with all recordings.\n";

	// block until the playback has finished
	// stopListener.waitForStop();

	// stop capture mode
	if (cameraDevice->stopCapture() != royale::CameraStatus::SUCCESS)
	{
		cerr << "Error stopping the capturing" << endl;
		return 1;
	}

	fakeReturn(0);
}
