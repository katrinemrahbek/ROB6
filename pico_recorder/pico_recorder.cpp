#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>
#include <fstream>
#include <sstream>
#include <string>
#include <cstdio>

#include <boost/filesystem.hpp>
#include <boost/thread.hpp>

#include "royale.hpp"
#include "royale/IPlaybackStopListener.hpp"
#include "royale/IReplay.hpp"
#include "sample_utils/PlatformResources.hpp"


class cameraListener : public royale::IDepthDataListener
{
public:
	cameraListener() :
		m_frameNumber(50), maxNumFrames(50), done(false)
	{
	}
	uint32_t m_frameNumber; // The current frame number
	uint32_t maxNumFrames;
	std::string filePrefix;
	bool done;

	void writePLY(const std::string &filename, const royale::DepthData *data)
	{
		// For an explanation of the PLY file format please have a look at
		// https://en.wikipedia.org/wiki/PLY_(file_format)

		std::ofstream outputFile;
		std::stringstream stringStream;

		outputFile.open(filename, std::ofstream::out);

		if (outputFile.fail())
		{
			std::cerr << "Outputfile " << filename << " could not be opened!" << std::endl;
			return;
		}
		else
		{
			// if the file was opened successfully write the PLY header
			stringStream << "ply" << std::endl;
			stringStream << "format ascii 1.0" << std::endl;
			stringStream << "comment Generated by pico_recorder" << std::endl;
			stringStream << "element vertex " << data->points.size() << std::endl;
			stringStream << "property float x" << std::endl;
			stringStream << "property float y" << std::endl;
			stringStream << "property float z" << std::endl;
			stringStream << "element face 0" << std::endl;
			stringStream << "property list uchar int vertex_index" << std::endl;
			stringStream << "end_header" << std::endl;

			// output XYZ coordinates into one line
			for (size_t i = 0; i < data->points.size(); ++i)
			{
				stringStream << data->points.at(i).x << " " << data->points.at(i).y << " " << data->points.at(i).z << std::endl;
			}

			// output stringstream to file and close it
			outputFile << stringStream.str();
			outputFile.close();
		}
	}

	void onNewData(const royale::DepthData *data) override
	{
		if (m_frameNumber < maxNumFrames)
		{
			std::stringstream filename;

			m_frameNumber++;

			std::cout << "Exporting frame " << m_frameNumber << std::endl;
			filename << filePrefix << "/" << m_frameNumber << ".ply";

			writePLY(filename.str(), data);
		}
		else
		{
			done = true;
		}
	}
};

int main(int argc, char *argv[])
{
	std::unique_ptr<cameraListener> listener;

	// Royale's API treats the .rrf file as a camera, which it captures data from.
	std::unique_ptr<royale::ICameraDevice> cameraDevice;
	royale::CameraManager manager;

	// if the file was loaded correctly the cameraDevice is now available
	if (cameraDevice == nullptr)
	{
		std::cerr << "Cannot open camera " << std::endl;
		return 1;
	}

	auto camlist = manager.getConnectedCameraList();
	std::cout << "Detected " << camlist.size() << " camera(s)." << std::endl;
	if (!camlist.empty())
	{
		std::cout << "CamID for first device: " << camlist.at(0).c_str() << " with a length of (" << camlist.at(0).length() << ")" << std::endl;
		cameraDevice = manager.createCamera(camlist[0]);
	}

	if (cameraDevice == nullptr)
	{
		std::cerr << "Cannot create the camera device" << std::endl;
		return 1;
	}

	// IMPORTANT: call the initialize method before working with the camera device
	if (cameraDevice->initialize() != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Cannot initialize the camera device" << std::endl;
		return 1;
	}


	/* available usecases from the pico flex
	0	MODE_9_5FPS_2000
	1	MODE_9_10FPS_1000
	2	MODE_9_15FPS_700
	3	MODE_9_25FPS_450
	4	MODE_5_35FPS_600
	5	MODE_5_45FPS_500
	6	MODE_MIXED_30_5
	7	MODE_MIXED_50_5
	8	Low_Noise_Extended
	9	Fast_Acquisition
		*/
	royale::Vector<royale::String> useCases;
	auto status = cameraDevice->getUseCases(useCases);
	for (auto stat : useCases)
		std::cout << stat << "\n";
	std::cout << "\n";

	if (status != royale::CameraStatus::SUCCESS || useCases.empty())
	{
		std::cerr << "No use cases are available" << std::endl;
		std::cerr << "getUseCases() returned: " << getErrorString(status) << std::endl;
		return 1;
	}

	// choose a use case
	auto selectedUseCaseIdx = 5u;
	std::cout << "Choosing useCase " << selectedUseCaseIdx << "\n";

	// set an operation mode
	if (cameraDevice->setUseCase(useCases.at(selectedUseCaseIdx)) != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Error setting use case" << std::endl;
		return 1;
	}

	std::vector<int> exposures = {50, 100, 200, 300, 400, 500 };
	if (cameraDevice->setExposureMode(royale::ExposureMode::MANUAL) != royale::CameraStatus::SUCCESS)
	{
		std::cout << "failed to set fixed exposure mode\n";
		return 1;
	}
	uint16_t maxFrameRate;
	cameraDevice->getFrameRate(maxFrameRate);
	std::cout << "framerate: " << maxFrameRate << "\n";

	// Create and register the data listener
	listener.reset(new cameraListener());
	if (cameraDevice->registerDataListener(listener.get()) != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Error registering data listener" << std::endl;
		return 1;
	}

	for (auto exposure : exposures)
	{
		if (cameraDevice->setExposureTime(exposure) != royale::CameraStatus::SUCCESS)
		{
			std::cout << "failed to set exposure: " << exposure << "\n";
			continue;
		}
		else
		{
			std::cout << "recording with exposure: " << exposure << "\n";
			std::string folderName = "exp_" + std::to_string(exposure);
			listener->filePrefix = folderName;
			listener->m_frameNumber = 0;
			listener->done = false;
			boost::filesystem::path dir(folderName);
			if (!boost::filesystem::create_directory(dir))
			{
				std::cout << "failed to create directory: " << folderName << "\n does it already exist? \n";
				continue;
			}
			// start capture mode
			if (cameraDevice->startCapture() != royale::CameraStatus::SUCCESS)
			{
				std::cerr << "Error starting the capturing" << std::endl;
				continue;
			}
			while (!listener->done)
			{
				boost::this_thread::sleep(boost::posix_time::microseconds(100000));
			}
			if (cameraDevice->stopCapture() != royale::CameraStatus::SUCCESS)
			{
				std::cerr << "Error stopping the capturing" << std::endl;
			}
		}
	}
	std::cout << "\n done with all recordings.\n";

	// stop capture mode
	if (cameraDevice->stopCapture() != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Error stopping the capturing" << std::endl;
		return 1;
	}

	return(0);
}
