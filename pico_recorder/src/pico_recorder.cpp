#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>
#include <fstream>
#include <sstream>
#include <string>
#include <cstdio>

#include <boost/filesystem.hpp>
#include <boost/thread.hpp>

#include "royale.hpp"
#include "royale/IPlaybackStopListener.hpp"
#include "royale/IReplay.hpp"
#include "sample_utils/PlatformResources.hpp"

#include "ArduinoSensorReader.h"

//globals to communicate and protect between threads
Sensordata sensordata;
bool hasArduinodata = false;
std::mutex arduinoMut;
std::mutex picoMut;

class cameraListener : public royale::IDepthDataListener
{
public:
	cameraListener() : hasData(false)
	{
	}
	bool hasData;
	royale::DepthData data;

	void writePLY(const std::string &filename, const royale::DepthData *data)
	{
		// For an explanation of the PLY file format please have a look at
		// https://en.wikipedia.org/wiki/PLY_(file_format)

		std::ofstream outputFile;
		std::stringstream stringStream;

		outputFile.open(filename, std::ofstream::out);

		if (outputFile.fail())
		{
			std::cerr << "Outputfile " << filename << " could not be opened!" << std::endl;
			return;
		}
		else
		{
			// if the file was opened successfully write the PLY header
			stringStream << "ply" << std::endl;
			stringStream << "format ascii 1.0" << std::endl;
			stringStream << "comment Generated by pico_recorder" << std::endl;
			stringStream << "element vertex " << data->points.size() << std::endl;
			stringStream << "property float x" << std::endl;
			stringStream << "property float y" << std::endl;
			stringStream << "property float z" << std::endl;
			stringStream << "element face 0" << std::endl;
			stringStream << "property list uchar int vertex_index" << std::endl;
			stringStream << "end_header" << std::endl;

			// output XYZ coordinates into one line
			for (size_t i = 0; i < data->points.size(); ++i)
			{
				stringStream << data->points.at(i).x << " " << data->points.at(i).y << " " << data->points.at(i).z << std::endl;
			}

			// output stringstream to file and close it
			outputFile << stringStream.str();
			outputFile.close();
		}
	}

	void onNewData(const royale::DepthData *data) override
	{
		picoMut.lock();
		this->data = *data;
		hasData = true;
		picoMut.unlock();
	}
};

int setupCamera(std::shared_ptr<royale::ICameraDevice> &cameraDevice)
{
	royale::CameraManager manager;

	auto camlist = manager.getConnectedCameraList();
	std::cout << "Detected " << camlist.size() << " camera(s)." << std::endl;
	if (!camlist.empty())
	{
		std::cout << "CamID for first device: " << camlist.at(0).c_str() << " with a length of (" << camlist.at(0).length() << ")" << std::endl;
		cameraDevice = manager.createCamera(camlist[0]);
	}

	if (cameraDevice == nullptr)
	{
		std::cerr << "Cannot create the camera device" << std::endl;
		return 1;
	}

	// IMPORTANT: call the initialize method before working with the camera device
	if (cameraDevice->initialize() != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Cannot initialize the camera device" << std::endl;
		return 1;
	}


	/* available usecases from the pico flex
	0	MODE_9_5FPS_2000
	1	MODE_9_10FPS_1000
	2	MODE_9_15FPS_700
	3	MODE_9_25FPS_450
	4	MODE_5_35FPS_600
	5	MODE_5_45FPS_500
	6	MODE_MIXED_30_5
	7	MODE_MIXED_50_5
	8	Low_Noise_Extended
	9	Fast_Acquisition
		*/
	royale::Vector<royale::String> useCases;
	auto status = cameraDevice->getUseCases(useCases);
	//for (auto stat : useCases)
	//	std::cout << stat << "\n";
	//std::cout << "\n";

	if (status != royale::CameraStatus::SUCCESS || useCases.empty())
	{
		std::cerr << "No use cases are available" << std::endl;
		std::cerr << "getUseCases() returned: " << getErrorString(status) << std::endl;
		return 1;
	}

	// choose a use case
	auto selectedUseCaseIdx = 5u;
	std::cout << "Choosing useCase " << selectedUseCaseIdx << "\n";

	// set an operation mode
	if (cameraDevice->setUseCase(useCases.at(selectedUseCaseIdx)) != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Error setting use case" << std::endl;
		return 1;
	}

	if (cameraDevice->setExposureMode(royale::ExposureMode::MANUAL) != royale::CameraStatus::SUCCESS)
	{
		std::cout << "failed to set fixed exposure mode\n";
		return 1;
	}
	uint16_t maxFrameRate;
	cameraDevice->getFrameRate(maxFrameRate);
	std::cout << "framerate: " << maxFrameRate << "\n";
	return 0;
}

void *arduino_thread_func(void *arg)
{
	ArduinoSensorReader* arduino  = (ArduinoSensorReader*)arg;
	while(1)
	{
		arduino->update();
		if(arduino->HasData())
		{
			arduinoMut.lock();
			sensordata = arduino->GetSensorData();
			hasArduinodata = true;
			arduinoMut.unlock();
		}
		boost::this_thread::sleep(boost::posix_time::microseconds(1000));
	}
}

int main(int argc, char *argv[])
{
	if(argc < 2)
	{
		std::cout << "give port for arduino as argument \n";
		return 1;
	}
	ArduinoSensorReader arduino(argv[1]);
	pthread_t arduino_thread;
	auto create = pthread_create(&arduino_thread, NULL, arduino_thread_func, (void*) &arduino);
	if(create != 0)
	{
		std::cout << "failed to create arduino thread? \n";
	}
	std::unique_ptr<cameraListener> listener;
	std::shared_ptr<royale::ICameraDevice> cameraDevice;

	auto result = setupCamera(cameraDevice);
	if(result != 0)
	{
		std::cout << "failed to setup camera" << "\n";
		return result;
	}
	// Create and register the data listener
	listener.reset(new cameraListener());

	if (cameraDevice->registerDataListener(listener.get()) != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Error registering data listener" << std::endl;
		return 1;
	}

	std::vector<int> exposures = {50, 100, 200, 300, 400, 500 };
	std::cout << "Starting to capture... \n";
	for (auto exposure : exposures)
	{
		if (cameraDevice->setExposureTime(exposure) != royale::CameraStatus::SUCCESS)
		{
			std::cout << "failed to set exposure: " << exposure << "\n";
			continue;
		}
		else
		{
			std::cout << "recording with exposure: " << exposure << "\n";
			std::string folderName = "exp_" + std::to_string(exposure);

			boost::filesystem::path dir(folderName);
			if (!boost::filesystem::create_directory(dir))
			{
				std::cout << "failed to create directory: " << folderName << "\n does it already exist? \n";
				continue;
			}
			// start capture mode
			if (cameraDevice->startCapture() != royale::CameraStatus::SUCCESS)
			{
				std::cerr << "Error starting the capturing" << std::endl;
				continue;
			}	

			int n_frames = 1;
			while (n_frames < 51)
			{
				arduinoMut.lock();
				if(hasArduinodata)
				{
					auto arduinoData = arduino.GetSensorData();
					hasArduinodata = false;
					arduinoMut.unlock();
					//std::cout << "got arduino data\n";
					picoMut.lock();
					royale::DepthData* picoData;
					if(listener->hasData)
					{
						picoData = &listener->data;
						listener->hasData = false;
						picoMut.unlock();
						//got the data, now save it as n.ply and n.txt
						std::string plyName, txtName;
						plyName = folderName + "/" + std::to_string(n_frames) + ".ply";
						txtName = folderName + "/" + std::to_string(n_frames) + ".txt";
						listener->writePLY(plyName, picoData);

						std::ofstream outputFile;
						std::stringstream stringstream;
						outputFile.open(txtName, std::ofstream::out);
						if (outputFile.fail())
						{
							std::cerr << "Outputfile " << txtName << " could not be opened!" << std::endl;
							return 0;
						}
						else
						{
							// output stringstream to file and close it
							stringstream << "#left, middle, right, roll, pitch, yaw\n";
							for(int i = 0; i < 3; i++)
								stringstream << std::to_string(arduinoData.sensor_readings[i]) << ",";
							for(int i = 0; i < 3; i++)
								stringstream << std::to_string(arduinoData.rpy[i]) << ",";
							std::string log = stringstream.str();
							std::cout << "log " << n_frames << " of 50: " << log << "\n";
							log.pop_back();
							outputFile << log;
							outputFile.close();
						}
						n_frames ++;
					}
					else
					{
						picoMut.unlock();
						boost::this_thread::sleep(boost::posix_time::microseconds(1000));
						continue;
					}
				}
				else
				{
					arduinoMut.unlock();
					boost::this_thread::sleep(boost::posix_time::microseconds(1000));
				}
			}
			if (cameraDevice->stopCapture() != royale::CameraStatus::SUCCESS)
			{
				std::cerr << "Error stopping the capturing" << std::endl;
			}
		}
	}
	std::cout << "\n done with all recordings.\n";

	// stop capture mode and end the program
	if (cameraDevice->stopCapture() != royale::CameraStatus::SUCCESS)
	{
		std::cerr << "Error stopping the capturing" << std::endl;
		return 1;
	}
	return(0);
}